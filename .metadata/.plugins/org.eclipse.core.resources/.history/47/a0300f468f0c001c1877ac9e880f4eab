package Pack;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.SocketAddress;
import java.net.SocketOption;
import java.util.*;

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;

//2) 리딩 스레드 만들기
class ClientThread extends Thread {
	//field
	String nickName = null;
	Socket ss = null;
	List<PrintWriter> listWriters = null;
	
	//constructor
	ClientThread(Socket ss, List<PrintWriter> listWriters) {
		this.ss = ss;
		this.listWriters = listWriters;
	}
	
	//method
	@Override
	public void run() {

		try {
			// 데이터 받기 (서버->InputStream)
			BufferedReader bufferdReader = new BufferedReader(
											new InputStreamReader(ss.getInputStream(),"UTF-8"));
			PrintWriter printWriter = new PrintWriter(
											new OutputStreamWriter(ss.getOutputStream(),"UTF-8"));
			// while로 받아야함. 그래야 계속 받고 블로킹 받고 블로킹 한다.
			while(true) {
				
				String request = bufferdReader.readLine();
				//연결 끊겼을때 START			
				if(request == null) {
					System.out.println("클라이언트로부터 연결 끊김");
					doQuit(printWriter);
					break;
				}
				// 연결 끊겼을때 END
				
				String[] tokens = request.split(":");
				if("join".equals(tokens[0])) {
					doJoin(tokens[1],printWriter);
				} else if ("message".equals(tokens[0])) {
					doMessage(tokens[1]);
				} else if ("quit".equals(tokens[0])) {
					doQuit(printWriter);
				}
				
				System.out.println(request + "데이터 받음");
			}
		} catch (Exception e) {
			// TODO: handle exception
			System.out.println(this.nickName + "님이 채팅방을 나갔습니다.");
		}
	}
	
//doQuit START
	private void doQuit(PrintWriter writer) {
		synchronized (listWriters) {
			listWriters.remove(writer);
		}
		String data = this.nickName + "님이 퇴장하셨습니다.";
		broadcast(data);
	}
//doQuit END

//doJoin START
	private void doJoin(String nickName, PrintWriter writer) {
		this.nickName = nickName;
		String data = nickName + "님이 입장하셨습니다.";
		broadcast(data);
		
		//writer pool에 저장
		synchronized (listWriters) {
			listWriters.add(writer);
		}
	}
//doJoin END

//doMessage START
	private void doMessage(String data) {
		broadcast(this.nickName + " : " + data);
	}
//doMessage END
	
//broadcast START
//	서버에 연결된 모든 클라이언트들에게 메시지를 전달하기 위한 메서드
	private void broadcast(String data) {
		System.out.println("1번 : " + data);
		synchronized (listWriters) {
			for (PrintWriter writer : listWriters) {
				System.out.println("2번 : " + data);
				writer.println(data);
				writer.flush();
			}
		}
		System.out.println("dddd");
	}
//broadcast END
	
}

//1) 서버 돌리기위해서 스레드 만들기
class ConnectThread extends Thread {
	public static final int port = 5001;
	
	
	@Override
	public void run() {
		// 서버의 메인 소캣 mss 생성
		ServerSocket mss = null;
		List<PrintWriter> listWriters = new ArrayList<PrintWriter>();
		try {
// 1. 서버 소켓 생성
			mss = new ServerSocket();
			System.out.println("Main Server Socket 생성");
// 2. 바인딩
//			mss.bind(new InetSocketAddress("localhost", 5001));
			mss.bind(new InetSocketAddress(InetAddress.getLocalHost(), port));
			System.out.println("바인딩 완료, accept()에 블로킹");

			// while 처리(다른 사람이 들어올거니까.)
// 3. 요청 대기(블로킹)
			while (true) {
				Socket ss = mss.accept(); // -> 리딩할때 ss가져가야함 -> 생성자로.
				System.out.println("누군가 접속 함.");
				new ClientThread(ss,listWriters).start();
				
				/*
				InetSocketAddress ISA = (InetSocketAddress)ss.getRemoteSocketAddress();
				String getHostName = ISA.getHostName();

				
				if(!listWriters.contains(getHostName)) {
					System.out.println("처음 접속");
				} else {
					System.out.println("중복 접속");
				}
				*/
			}

		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
//		private static void consoleLog(String log) {
//			 System.out.println("[server " + Thread.currentThread().getId() + "] " + log);
//		}
	}
}

public class Server extends Application{
	
	@Override
	public void start(Stage arg0) throws Exception {
		// System.out.println("실행순서 2");
		// 선두작업
		VBox root = new VBox();
		root.setPrefSize(400, 300);
		root.setSpacing(55);

		// ---------------------------------------------
		// 1.컨트롤을 배치
		Button btn1 = new Button("Server Open");
		Button btn2 = new Button("Test");
		
		// 2. 컨트롤에 대한 이벤트 처리

		
		//1) Server Open
		btn1.setOnAction((AE)->{
			//접속 기다리면서 블로킹될거기때문에 스레드로 만들었다.
			new ConnectThread().start();
		});
		
		btn2.setOnAction((AE)->{
			
		});
	
		root.getChildren().addAll(btn1, btn2);
		// ---------------------------------------------

		// 마무리작업
		Scene scene = new Scene(root);
		arg0.setTitle("Server");// Title 설정
		arg0.setScene(scene); // UI구성 장면을 Scene으로 등록
		arg0.show(); // 등록한 Scene을 보여줌

		// System.out.println("실행순서 3");
	}

	public static void main(String[] args) {
		// System.out.println("실행순서 1");
		launch(); // launcher 에서 블로킹 잡힌다. 런쳐 종료하면 나옴
		// System.out.println("실행순서 4");
		System.out.println("Exit");
	}

}

/*
public class Server {

	public static void main(String[] args) {
		System.out.println("Server Start");
		//네트워크를 위해서 서버 스타트
		
		//서버에서 쓸 메인 소켓 만들기(main server socket)
		try {
			//서버의 메인 소캣 mss
			ServerSocket mss = new ServerSocket();
			System.out.println("Main Server Socket 생성");
			
			//Port..(패스워드) 바인딩
//			통과를 시켜주려면 통과시켜줄 담당자가 패스워드를 알아야 하는데 
//			통과시켜줄 담당자한테 패스워드를 기억시키는 것
			
			//메인 서버 소캣은 1. 내 주소 알아야함 2. 들어오는놈 주소 알아야함.
//			port번호(1024 이후 권장, 충돌일어날수도..3000번 이상 쓰면 상관없을듯)
//			port번호는 외부에서 접속할때 비밀번호라고 생각해라..(port번호 쌍방간에 안맞으면 통신 불가)
//			mss.bind(new InetSocketAddress(InetAddress.getLocalHost(), 5001));
			mss.bind(new InetSocketAddress("localhost", 5001));
			//서버에다가 통과시켜줄 정보를 기억시킴.
			System.out.println("바인딩 완료, accept()에 블로킹");
			
			//서버에 누가 접속할때까지 이제 기다린다.
			//누군가 접속하면 대화하기 위한 통신 소켓이 생겨야함.
			Socket ss = mss.accept(); //블로킹함수(접속할때까지 대기)
			System.out.println("누군가 접속 함.");
			//데이터 받기 (서버->InputStream)
			
			InputStream inputStream = ss.getInputStream();
			//inputStream.read() 블로킹함수이다.
			//Client한테 데이터 받아와야한다.
			//while로 받아야함. 그래야 계속 받고 블로킹 받고 블로킹 한다.
			byte[] data = new byte[512];	//2의 배수
			int size = inputStream.read(data);	//return하면 데이터 크기 나옴.
			//byte로 받은 데이터를 String으로
			String str = new String(data, 0, size);	//data배열 0~데이터 크기만큼.
			System.out.println(str + "데이터 받음");
			
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		new Scanner(System.in).nextInt(); //블로킹
		
		System.out.println("Server End");
	}
}
*/
