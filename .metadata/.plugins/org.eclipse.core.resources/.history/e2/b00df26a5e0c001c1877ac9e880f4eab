package Pack;

import java.io.IOException;
import java.io.InputStream;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.SocketAddress;
import java.net.SocketOption;
import java.util.*;

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;

//2) 리딩 스레드 만들기
class ClientThread extends Thread {

	Socket ss;

	ClientThread(Socket ss) {
		this.ss = ss;
	}

	@Override
	public void run() {

		try {
			// 데이터 받기 (서버->InputStream)
			InputStream inputStream = ss.getInputStream(); // ss = 통신 소켓
			// inputStream.read() 블로킹함수이다.
			// Client한테 데이터 받아와야한다.
			// while로 받아야함. 그래야 계속 받고 블로킹 받고 블로킹 한다.
			while(true) {
				byte[] data = new byte[512]; // 2의 배수
				int size = inputStream.read(data); // return하면 데이터 크기 나옴.
				// byte로 받은 데이터를 String으로
				String str = new String(data, 0, size); // data배열 0~데이터 크기만큼.
				System.out.println(str + "데이터 받음");
			}
		} catch (Exception e) {
			// TODO: handle exception
		}
	}
}

//1) 서버 돌리기위해서 스레드 만들기
class ConnectThread extends Thread {
	public ServerSocket mss;
	List<String> cliInfo = new ArrayList<String>();
	
	@Override
	public void run() {
		// 서버의 메인 소캣 mss
		try {
			mss = new ServerSocket();
			
			System.out.println("Main Server Socket 생성");

//			mss.bind(new InetSocketAddress("localhost", 5001));
			mss.bind(new InetSocketAddress(InetAddress.getLocalHost(), 5001));
			System.out.println("바인딩 완료, accept()에 블로킹");

			// while 처리(다른 사람이 들어올거니까.)
			while (true) {
				// 블로킹(접속할때까지 대기)
				Socket ss = mss.accept(); // -> 리딩할때 ss가져가야함 -> 생성자로.
				InputStream inputStream = ss.getInputStream();
				byte[] data = new byte[128];
				int size = inputStream.read(data);
				String userName = new String(data, 0, size);
				
				InetSocketAddress ISA = (InetSocketAddress)ss.getRemoteSocketAddress();
				String remoteHostName = ISA.getAddress().getHostAddress();
				int remoteHostPort = ISA.getPort();
				String getHostName = ISA.getHostName();
				
				/*
				System.out.println("InetSocketAddress : " + ISA);
				System.out.println("remoteHostName : " + remoteHostName);
				System.out.println("getHostName : " + getHostName);
				System.out.println("remoteHostPort : " + remoteHostPort);
				*/
				
				if(!cliInfo.contains(getHostName)) {
					cliInfo.add("220.119.22.242");
					cliInfo.add(getHostName);
					System.out.println("현재 " + userName + "님이 접속하셨습니다.");
					System.out.println(cliInfo.size());
				} else {
					System.out.println("현재 " + userName + "님은 접속중입니다.");
					System.out.println(cliInfo.size());
				}

//				System.out.println("List : " + cliInfo.get(0));
				System.out.println("누군가 접속 함.");
				// 요놈 handle은 블로킹돼있다고 멈춰있으면 다른 작업을 할 수가 없다.->스레드로 빠져야함.
				
				// 리딩 처리를 한다. -> 또 블로킹 된다.
				// -> 데이터를 받기전에는 다른 사람이 접속을 못한다. -> 리딩용 스레드 만들어서 발동.
				new ClientThread(ss).start();
				//
			}

		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
}

public class Server extends Application{

	
	@Override
	public void start(Stage arg0) throws Exception {
		// System.out.println("실행순서 2");
		// 선두작업
		VBox root = new VBox();
		root.setPrefSize(400, 300);
		root.setSpacing(55);

		// ---------------------------------------------
		// 1.컨트롤을 배치
		Button btn1 = new Button("Server Open");
		Button btn2 = new Button("Test");
		
		// 2. 컨트롤에 대한 이벤트 처리

		
		//1) Server Open
		btn1.setOnAction((AE)->{
			//접속 기다리면서 블로킹될거기때문에 스레드로 만들었다.
			new ConnectThread().start();
		});
		
		btn2.setOnAction((AE)->{
			
		});
	
		root.getChildren().addAll(btn1, btn2);
		// ---------------------------------------------

		// 마무리작업
		Scene scene = new Scene(root);
		arg0.setTitle("Server");// Title 설정
		arg0.setScene(scene); // UI구성 장면을 Scene으로 등록
		arg0.show(); // 등록한 Scene을 보여줌

		// System.out.println("실행순서 3");
	}

	public static void main(String[] args) {
		// System.out.println("실행순서 1");
		launch(); // launcher 에서 블로킹 잡힌다. 런쳐 종료하면 나옴
		// System.out.println("실행순서 4");
		System.out.println("Exit");
	}

}

/*
public class Server {

	public static void main(String[] args) {
		System.out.println("Server Start");
		//네트워크를 위해서 서버 스타트
		
		//서버에서 쓸 메인 소켓 만들기(main server socket)
		try {
			//서버의 메인 소캣 mss
			ServerSocket mss = new ServerSocket();
			System.out.println("Main Server Socket 생성");
			
			//Port..(패스워드) 바인딩
//			통과를 시켜주려면 통과시켜줄 담당자가 패스워드를 알아야 하는데 
//			통과시켜줄 담당자한테 패스워드를 기억시키는 것
			
			//메인 서버 소캣은 1. 내 주소 알아야함 2. 들어오는놈 주소 알아야함.
//			port번호(1024 이후 권장, 충돌일어날수도..3000번 이상 쓰면 상관없을듯)
//			port번호는 외부에서 접속할때 비밀번호라고 생각해라..(port번호 쌍방간에 안맞으면 통신 불가)
//			mss.bind(new InetSocketAddress(InetAddress.getLocalHost(), 5001));
			mss.bind(new InetSocketAddress("localhost", 5001));
			//서버에다가 통과시켜줄 정보를 기억시킴.
			System.out.println("바인딩 완료, accept()에 블로킹");
			
			//서버에 누가 접속할때까지 이제 기다린다.
			//누군가 접속하면 대화하기 위한 통신 소켓이 생겨야함.
			Socket ss = mss.accept(); //블로킹함수(접속할때까지 대기)
			System.out.println("누군가 접속 함.");
			//데이터 받기 (서버->InputStream)
			
			InputStream inputStream = ss.getInputStream();
			//inputStream.read() 블로킹함수이다.
			//Client한테 데이터 받아와야한다.
			//while로 받아야함. 그래야 계속 받고 블로킹 받고 블로킹 한다.
			byte[] data = new byte[512];	//2의 배수
			int size = inputStream.read(data);	//return하면 데이터 크기 나옴.
			//byte로 받은 데이터를 String으로
			String str = new String(data, 0, size);	//data배열 0~데이터 크기만큼.
			System.out.println(str + "데이터 받음");
			
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		new Scanner(System.in).nextInt(); //블로킹
		
		System.out.println("Server End");
	}
}
*/
